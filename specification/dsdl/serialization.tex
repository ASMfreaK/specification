\section{Data serialization}\label{sec:dsdl_data_serialization}

\newcommand{\hugett}[1]{\texttt{\huge{#1}}}

\subsection{General principles}

\subsubsection{Design goals}

The main design principle behind the serialized representations described in this section is
the maximization of compatibility with native representations used by currently existing and
likely future computer microarchitectures.
The goal is to ensure that the serialized representations defined by DSDL match internal data representations of
modern computers, so that, ideally, a typical system will not have to perform any data conversion whatsoever while
exchanging data over a UAVCAN network.

\subsubsection{Bit and byte ordering}

The smallest atomic data entity is a bit.
Eight bits form one byte;
within the byte, the bits are ordered so that the most significant bit is considered first (0-th index),
and the least significant bit is considered last (7-th index).

Numeric values consisting of multiple bytes are encoded so that the least significant byte is encoded first;
such format is also known as little-endian.

\begin{figure}[H]
    $$
    \overset{\text{bit index}}{%
        \underbrace{%
            \overset{0}{\hugett{\;0\;}}
            \overset{1}{\hugett{\;1\;}}
            \overset{2}{\hugett{\;0\;}}
            \overset{3}{\hugett{\;1\;}}
            \overset{4}{\hugett{\;0\;}}
            \overset{5}{\hugett{\;1\;}}
            \overset{6}{\hugett{\;0\;}}
            \overset{7}{\hugett{\;1\;}}
        }_{\substack{\text{0-th byte} \\ \text{least significant byte}}}%
    }
    \hugett{\ldots}
    \overset{\text{bit index}}{%
        \underbrace{%
            \overset{8n+0}{\hugett{\;0\;}}
                          {\hugett{\;1\;}}
            \overset{8n+2}{\hugett{\;0\;}}
                          {\hugett{\;1\;}}
                          {\hugett{\;0\;}}
            \overset{8n+5}{\hugett{\;1\;}}
                          {\hugett{\;0\;}}
            \overset{8n+7}{\hugett{\;1\;}}
        }_{\substack{n\text{-th byte} \\ \text{most significant byte}}}%
    }
    $$
    \caption{Bit and byte ordering.\label{fig:dsdl_serialization_bit_ordering}}
\end{figure}

\subsubsection{Implicit padding}

Excepting one edge case reviewed below,
serialized representations of DSDL entities never include implicit data padding.
Unaligned data may lead to suboptimal serialization and deserialization performance;
therefore, the data type designer should manually align elements as necessary to prevent performance degradation.
It is guaranteed, however, that unaligned data cannot result in unspecified or otherwise unexpected behavior
of the data handling routines.
The manual approach to data alignment allows the data type designer to trade-off serialization efficiency
over network bandwidth utilization and data transfer latency as necessary without compromising functional safety.

The exceptional edge case mentioned above when implicit padding is introduced is as follows.
Serialized representations of DSDL entities operate at the bit level,
whereas the transport protocols supported by UAVCAN\footnote{As well as the majority of network protocols in general.}
use byte as the smallest atomic data element.
The resulting mismatch of the data granularity levels is resolved by
appending the serialized representation of the top-level composite type object with zero (0) bits
until the length of its bit string is an integer multiple of eight (8).
The term \emph{top-level object} denotes an object that is not nested inside another DSDL entity.
In other words, padding bits may only be added before a fully constructed serialized representation is
handed over for transmission over the UAVCAN network
(or any other destination which does not support bit-level data granularity).

Additionally, the transport layer may introduce extra padding at the end of the serialized representation,
as described in relevant sections of chapter \ref{sec:transport_layer};
however, such padding behavior falls outside of the scope of the DSDL specification
as it belongs to the domain of network transports rather than data presentation.

When a serialized representation is deconstructed, the value of the trailing padding bits must be ignored.

\subsection{Void types}

The serialized representation of a void-typed field attribute is constructed as a sequence of zero bits.
The length of the sequence equals the numeric suffix of the type name.

When a void-typed field attribute is decoded, the values of respective bits are ignored;
in other words, any bit sequence of correct length is a valid encoded representation of a void-typed field attribute.
This behavior facilitates usage of void fields as placeholders for non-void fields
introduced in newer versions of the data type (section \ref{sec:dsdl_versioning}).

\begin{remark}
    The following data schema will be encoded as a sequence of three zero bits $000_2$
    (five trailing padding bits not included):
    \begin{minted}{python}
        void3
    \end{minted}
    The following bit sequences are valid encoded representations of the schema:
    $000_2$,
    $001_2$,
    $010_2$,
    $011_2$,
    $100_2$,
    $101_2$,
    $110_2$,
    $111_2$.
\end{remark}

\subsection{Primitive types}

\subsubsection{Boolean types}\label{sec:dsdl_serialized_bool}

The serialized representation of a value of type \verb|bool| is a single bit.
If the value represents falsity, the value of the bit is zero (0); otherwise, the value of the bit is one (1).

\subsubsection{Unsigned integer types}\label{sec:dsdl_serialized_unsigned_integer}

The serialized representation of an unsigned integer value of length $n$ bits
(which is reflected in the numerical suffix of the data type name)
is constructed as if the number were to be written in base-2 numerical system
with leading zeros preserved so that the total number of binary digits would equal $n$.

\begin{remark}
    The serialized representation of integer 123 of type \verb|uint9| is $001111011_2$.
\end{remark}

\subsubsection{Signed integer types}

The serialized representation of a non-negative value of a signed integer type is constructed as described
in section \ref{sec:dsdl_serialized_unsigned_integer}.

The serialized representation of a negative value of a signed integer type is computed by
applying the following transformation:
$$2^n + x$$
where $n$ is the bit length of the serialized representation
(which is reflected in the numerical suffix of the data type name)
and $x$ is the value whose serialized representation is being constructed.
The result of the transformation is a positive number,
whose serialized representation is then constructed as described in section \ref{sec:dsdl_serialized_unsigned_integer}.

The representation described here is widely known as \emph{two's complement}.

\begin{remark}
    The serialized representation of integer -123 of type \verb|int9| is $110000101_2$.
\end{remark}

\subsubsection{Floating point types}

The serialized representation of floating point types follows the IEEE 754 series of standards as follows:

\begin{itemize}
    \item \verb|float16| --- IEEE 754 binary16;
    \item \verb|float32| --- IEEE 754 binary32;
    \item \verb|float64| --- IEEE 754 binary64.
\end{itemize}

\subsection{Array types}

\subsubsection{Fixed-length array types}

Serialized representations of a fixed-length array of $n$ elements of type $T$ and
a sequence of $n$ field attributes of type $T$ are equivalent.

\begin{remark}
    Serialized representations of the following two data schema definitions are equivalent:

    \begin{minted}{python}
        AnyType[3] array
    \end{minted}

    \begin{minted}{python}
        AnyType item_0
        AnyType item_1
        AnyType item_2
    \end{minted}
\end{remark}

\subsubsection{Variable-length array types}

The serialized representation of a variable-length array consists of two segments:
the implicit length field followed by the array elements.

The implicit length field is an unsigned integer value whose serialized representation
is implicitly injected in the beginning of the serialized representation of its array.
The bit length of the unsigned integer value is determined as follows:
$$\lceil{}\log_2 (c + 1)\rceil{}$$
where $c$ is the capacity (i.e., the maximum number of elements) of the variable-length array.
The number of elements $n$ contained in the variable-length array is encoded in the serialized representation
of the implicit length field as described in section \ref{sec:dsdl_serialized_unsigned_integer}
(including the case where the bit length of the implicit length field is one bit).

The rest of the serialized representation is constructed as if the variable-length array was
a fixed-length array of $n$ elements.

\begin{remark}
    It is recommended to manually align variable-length arrays by prepending them with padding field attributes
    so that the first element is byte-aligned, as that facilitates more efficient serialization and deserialization.

    \begin{minted}{python}
        void2                        # Padding - good practice but not required
        AnyType[<42] array           # The implicit length field is 6 bits wide
        @assert _offset_.min == 8    # Ensuring that the first element is byte-aligned
    \end{minted}

    If the array contained three elements,
    the resulting set of its serialized representations would be equivalent to that of the following definition:

    \begin{minted}{python}
        void2                        # Padding - good practice but not required
        uint6 implicit_length_field  # Set to 3, because the array contains three elements
        AnyType item_0
        AnyType item_1
        AnyType item_2
    \end{minted}
\end{remark}

\subsection{Composite types}

A serialized representation of an object of composite type $T$ is an ordered set of serialized representations of
its field attribute values joined into a bit string.
The ordering of the serialized representations of the field attribute values follows the order
of field attribute declaration of $T$.

Bit strings do not have any implicit entities such as padding or headers.
Data type developers are advised\footnote{But not required.} to manually align field attributes at
byte boundaries using padding field attributes in order to simplify data layouts
and improve the performance of serialization and deserialization routines.

\begin{remark}
    Consider the following data schema definition,
    where the fields are assigned runtime values shown in the comments:

    \begin{minted}{python}
        #                          decimal    bit string            comment
        truncated uint12 first   # +48858     1011_1110_1101_1010   overflow, MSB truncated
        saturated int3   second  # -1         111                   two's complement
        saturated int4   third   # -5         1011                  two's complement
        saturated int2   fourth  # -1         11                    two's complement
        truncated uint4  fifth   # +136       1000_1000             overflow, MSB truncated
    \end{minted}

    It can be seen that the bit layout is rather complicated because the field boundaries do not align with byte
    boundaries, which makes it a good case study.
    The resulting serialized byte sequence is shown below in the base-2 system,
    where bytes (octets) are comma-separated:
    $$
        \overbrace{\hugett{11011010,1110}}^{\texttt{first}}%
        \underbrace{\hugett{111}}_{\texttt{second}}%
        \overbrace{\hugett{1,011}}^{\texttt{third}}%
        \underbrace{\hugett{11}}_{\texttt{fourth}}%
        \overbrace{\hugett{100,0}}^{\texttt{fifth}}%
        \underbrace{\hugett{???????}}_{\substack{\text{Next object or} \\ \text{zero padding bits}}}
    $$
\end{remark}

Nested data structures are serialized directly in-place,
as if their DSDL definition was pasted directly in place of their reference.
No additional prefixes, suffixes, or padding is provided.

\subsubsection{Tagged unions}

Similar to variable-length arrays, a serialized representation of a tagged union consists of two segments:
the implicit \emph{union tag} followed by the selected field attribute.

The implicit union tag is an unsigned integer value whose serialized representation
is implicitly injected in the beginning of the serialized representation of its tagged union.
The bit length of the unsigned integer value is determined as follows:
$$\lceil{}\log_2 n\rceil{}$$
where $n$ is the number of field attributes in the union.

Each of the tagged union field attributes is assigned an index in the order of their definition;
their order follows that of the DSDL statements (see section \ref{sec:dsdl_grammar} on statement ordering).
The first defined field attribute is assigned the index 0 (zero),
the index of the following field is incremented by one.

The index $i$ of the field attribute whose value is currently held by the tagged union is encoded
in the serialized representation of the implicit union tag as described in section
\ref{sec:dsdl_serialized_unsigned_integer}
(including the case where the bit length of the implicit length field is one bit).

\begin{remark}
    It is recommended to manually align unions when they are nested into outer data types by
    prepending them with void fields so that the elements are byte-aligned,
    as that enables more efficient serialization and deserialization.

    Consider the following example:

    \begin{minted}{python}
        @union                  # In this case, the union tag requires 2 bits
        uint16  FOO = 42        # A regular constant attribute
        uint16  a               # Index 0
        uint8   b               # Index 1
        float64 c               # Index 2
        uint32  BAR = 42        # Another regular constant
    \end{minted}

    In order to encode the field \verb|b|, which, according to the definition,
    has the data type \verb|uint8|, the union tag should be assigned the value 1.
    The following structure will have an identical layout:

    \begin{minted}{python}
        uint2 implicit_union_tag  # Set to 1
        uint8 b                   # The actual data
    \end{minted}

    Suppose that the value of \verb|b| is 7. The resulting bit string is shown below in the base-2 system:
    $$%
    \underbrace{\hugett{01}}_{\substack{\text{union} \\ \text{tag}}}%
    \underbrace{\hugett{00000111}}_{\text{field }\texttt{b}}%
    $$
\end{remark}

