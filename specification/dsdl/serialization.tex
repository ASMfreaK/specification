\section{Data serialization}\label{sec:dsdl_data_serialization}

The main design principle behind the serialized representations described in this section is
the maximization of compatibility with native representations used by currently existing and
likely future computer microarchitectures.
The goal is to ensure that the serialized representations defined by DSDL match internal data representations of
modern computers, so that, ideally, a typical system will not have to perform any data conversion whatsoever while
exchanging data over a UAVCAN network.

\newcommand{\hugett}[1]{\texttt{\huge{#1}}}

\subsection{General principles}

The smallest atomic data entity is a bit.
Eight bits form one byte;
within the byte, the bits are ordered so that the most significant bit is considered first (0-th index),
and the least significant bit is considered last (7-th index).

Numeric values consisting of multiple bytes are encoded so that the least significant byte is encoded first;
such format is also known as little-endian.

\begin{figure}[H]
    $$
    \overset{\text{bit index}}{%
        \underbrace{%
            \overset{0}{\hugett{0}}\quad
            \overset{1}{\hugett{1}}\quad
            \overset{2}{\hugett{0}}\quad
            \overset{3}{\hugett{1}}\quad
            \overset{4}{\hugett{0}}\quad
            \overset{5}{\hugett{1}}\quad
            \overset{6}{\hugett{0}}\quad
            \overset{7}{\hugett{1}}\quad
        }_{\substack{\text{0-th byte} \\ \text{least significant byte}}}%
    }
    \hugett{\ldots}
    \overset{\text{bit index}}{%
        \underbrace{%
            \overset{8n+0}{\hugett{0}}\quad
            \overset{8n+1}{\hugett{1}}\quad
            \overset{8n+2}{\hugett{0}}\quad
            \overset{8n+3}{\hugett{1}}\quad
            \overset{8n+4}{\hugett{0}}\quad
            \overset{8n+5}{\hugett{1}}\quad
            \overset{8n+6}{\hugett{0}}\quad
            \overset{8n+7}{\hugett{1}}\quad
        }_{\substack{n\text{-th byte} \\ \text{most significant byte}}}%
    }
    $$
    \caption{Bit ordering and grouping.\label{fig:dsdl_serialization_bit_ordering}}
\end{figure}

Upon completion, a bit sequence must be appended with zero (0) bits at the end until the total length of
the bit sequence is an integer multiple of eight (8).
The transport layer may introduce additional padding bytes (as opposed to bits) of arbitrary values,
as described in relevant sections of chapter \ref{sec:transport_layer}.
When a serialized representation is deconstructed, the values of the padding bits must be ignored.

\subsection{Void types}

The serialized representation of a void-typed field attribute is constructed as a sequence of zero bits.
The length of the sequence equals the numeric suffix of the type name.

When a void-typed field attribute is decoded, the values of respective bits are ignored;
in other words, any bit sequence of correct length is a valid encoded representation of a void-typed field attribute.
This behavior facilitates usage of void fields as placeholders for non-void fields
introduced in newer versions of the data type (section \ref{sec:dsdl_versioning}).

\begin{remark}
    The following data schema will be encoded as a sequence of three zero bits $000_2$
    (five trailing padding bits not included):
    \begin{minted}{python}
        void3
    \end{minted}
    The following bit sequences are valid encoded representations of the schema:
    $000_2$,
    $001_2$,
    $010_2$,
    $011_2$,
    $100_2$,
    $101_2$,
    $110_2$,
    $111_2$.
\end{remark}

\subsection{Primitive types}

\subsubsection{Boolean types}

The serialized representation of a value of type \verb|bool| is a single bit.
If the value represents falsity, the value of the bit is zero (0); otherwise, the value of the bit is one (1).

\subsubsection{Unsigned integer types}\label{sec:dsdl_serialized_unsigned_integer}

The serialized representation of an unsigned integer value of length $n$ bits
(which is reflected in the numerical suffix of the data type name)
is constructed as if the number were to be written in base-2 numerical system
with leading zeros preserved so that the total number of binary digits would equal $n$.

\begin{remark}
    The serialized representation of integer 123 of type \verb|uint9| is $001111011_2$.
\end{remark}

\subsubsection{Signed integer types}

The serialized representation of a non-negative value of a signed integer type is constructed as described
in section \ref{sec:dsdl_serialized_unsigned_integer}.

The serialized representation of a negative value of a signed integer type is computed by
applying the following transformation:
$$2^n + x$$
where $n$ is the bit length of the serialized representation
(which is reflected in the numerical suffix of the data type name)
and $x$ is the value whose serialized representation is being constructed.
The result of the transformation is a positive number,
whose serialized representation is then constructed as described in section \ref{sec:dsdl_serialized_unsigned_integer}.

The representation described here is widely known as \emph{two's complement}.

\begin{remark}
    The serialized representation of integer -123 of type \verb|int9| is $110000101_2$.
\end{remark}

\subsubsection{Floating point types}

The serialized representation of floating point types follows the IEEE 754 series of standards as follows:

\begin{itemize}
    \item \verb|float16| --- IEEE 754 binary16;
    \item \verb|float32| --- IEEE 754 binary32;
    \item \verb|float64| --- IEEE 754 binary64.
\end{itemize}

\subsection{Nested data structures}

Nested data structures are serialized directly in-place,
as if their DSDL definition was pasted directly in place of their reference.
No additional prefixes, suffixes, or padding is provided.

\subsection{Fixed size arrays}

Fixed-size arrays are serialized as a plain sequence of items,
with each item serialized independently in place, with no alignment.
No extra data is added.

Essentially, a fixed-size array of size $X$ elements will be serialized exactly in the same way
as a sequence of $X$ fields of the same type in a row.
Hence, the following two data type definitions will have identical binary representation,
the only actual difference being their representation for the application
if automatic code generation is used.

\begin{minted}{python}
AnyType[3] array
\end{minted}

\begin{minted}{python}
AnyType item_0
AnyType item_1
AnyType item_2
\end{minted}

\subsection{Dynamic arrays}

The following two array definitions are equivalent;
the difference is their representation in the DSDL definition for better readability:
\begin{minted}{python}
AnyType[<42] a      # Can contain from 0 to 41 elements
AnyType[<=41] b     # Can contain from 0 to 41 elements
\end{minted}

A dynamic array is serialized as a sequence of serialized items prepended with an unsigned
integer field representing the number of contained items - the \emph{length field}.
The bit width of the length field is a function of the maximum number of items in the array:
$$\lceil{}\log_2 (X + 1)\rceil{}$$
where $X$ is the maximum number of items in the array.
For example, if the maximum number of items is 251, the length field bit width must be 8 bits;
if the maximum number of items is 1, the length field bit width will be just a single bit.

It is recommended to manually align dynamic arrays by prepending them with void fields
so that the first element is byte-aligned, as that enables more efficient serialization and
deserialization.
This recommendation does not need to be followed if the size of the array elements is not
a multiple of eight bits or if the array elements are of variable size themselves
(e.g., a dynamic array of nested types which contain dynamic arrays themselves).

Consider the following definition:

\begin{minted}{python}
void2                       # Padding - not required, provided as an example
AnyType[<42] array          # The length field is 6 bits wide (see the formula)
\end{minted}

If the array contained three elements,
the resulting binary representation would be equivalent to that of the following definition:

\begin{minted}{python}
void2                       # Padding - not required, provided as an example
uint6 array_length          # Set to 3, because the array contains three elements
AnyType item_0
AnyType item_1
AnyType item_2
\end{minted}

\subsection{Unions}

Similar to dynamic arrays, tagged unions are serialized as two subsequent entities:
the union tag followed by the selected field, with no additional data.

The union tag is an unsigned integer, the bit length of which is a function of the number of fields in the union:
$$\lceil{}\log_2 N\rceil{}$$
where N is the number of fields in the union.
The value serialized in the union tag is the index of the selected field.
Field indexes are assigned according to the order in which they are defined in DSDL,
starting from zero;
i.e. the first defined field has the index 0, the second defined field has the index 1, and so on.

Constants are not affected by the union tag.

It is recommended to manually align unions when they are nested into outer data types by
prepending them with void fields so that the elements are byte-aligned,
as that enables more efficient serialization and deserialization.

Consider the following example:

\begin{minted}{python}
@union                  # In this case, the union tag requires 2 bits
uint16  FOO = 42        # A regular constant attribute
uint16  a               # Index 0
uint8   b               # Index 1
float64 c               # Index 2
uint32  BAR = 42        # Another regular constant
\end{minted}

In order to encode the field \verb|b|, which, according to the definition,
has the data type \verb|uint8|, the union tag should be assigned the value 1.
The following structure will have an identical layout:

\begin{minted}{python}
uint2 tag               # Set to 1
uint8 b                 # The actual data
\end{minted}

If the value of \verb|b| was 7, the resulting serialized byte sequence would be (in binary):
$$%
\underbrace{\texttt{01}}_{\text{tag}}%
\overbrace{\texttt{000001 11}}^{\text{field }\texttt{b}}%
\underbrace{\texttt{000000}}_{\text{padding}}%
$$

\subsection{Composite types}

A serialized representation of an object of composite type $T$ is an ordered set of serialized representations of
its field attribute values joined into a bit string.
The ordering of the serialized representations of the field attribute values follows the order
of field attribute declaration of $T$.

Bit strings do not have any implicit entities such as padding or headers.
Data type developers are advised\footnote{But not required.} to manually align field attributes at
byte boundaries using padding field attributes in order to simplify data layouts
and improve the performance of serialization and deserialization routines.

\begin{remark}
    Consider the following data schema definition,
    where the fields are assigned runtime values shown in the comments:

    \begin{minted}{python}
        #                          decimal    bit string            comment
        truncated uint12 first   # +48858     1011_1110_1101_1010   overflow, MSB truncated
        truncated int3   second  # -1         111                   two's complement
        truncated int4   third   # -5         1011                  two's complement
        truncated int2   fourth  # -1         11                    two's complement
        truncated uint4  fifth   # +136       1000_1000             overflow, MSB truncated
    \end{minted}

    It can be seen that the bit layout is rather complicated because the field boundaries do not align with byte
    boundaries, which makes it a good case study.
    The resulting serialized byte sequence is shown below in the base-2 system,
    where bytes (octets) are comma-separated:

    $$
        \overbrace{\hugett{11011010,1110}}^{\texttt{first}}%
        \underbrace{\hugett{111}}_{\texttt{second}}%
        \overbrace{\hugett{1,011}}^{\texttt{third}}%
        \underbrace{\hugett{11}}_{\texttt{fourth}}%
        \overbrace{\hugett{100,0}}^{\texttt{fifth}}%
        \underbrace{\hugett{0000000}}_{\substack{\text{Implicit padding} \\ \text{to 8-bit alignment}}}
    $$
\end{remark}
