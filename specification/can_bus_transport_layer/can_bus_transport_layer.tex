\chapter{CAN bus transport layer}\label{sec:can_bus_transport_layer}

This chapter defines the CAN bus based transport layer of UAVCAN,
both for CAN 2.0 and for CAN FD.
The differences between the two transports are minor,
so by default all of the information provided in this chapter applies to both,
unless specifically stated otherwise.

\section{The concept of transfer}

A \emph{transfer} is an act of data transmission between nodes.
A transfer that is addressed to all nodes except the source node is a \emph{broadcast transfer}.
A transfer that is addressed to one particular node is a \emph{unicast transfer}.
UAVCAN defines the following types of transfers:

\begin{description}
    \item[Message transfer] - a broadcast transfer that contains a serialized message.
    \item[Service transfer] - a unicast transfer that contains either a service request or a service response.
\end{description}

Both message and service transfers can be further distinguished between:

\begin{description}
    \item[Single-frame transfer] - a transfer that is entirely contained in a single CAN frame.
    The amount of data that can be exchanged using single-frame transfers is dependent on the transport protocol in use.

    \item[Multi-frame transfer] - a transfer that has its payload distributed over multiple CAN frames.
    The UAVCAN protocol stack handles transfer decomposition and reassembly automatically.
\end{description}

The following properties are common to all types of transfers:

\begin{UAVCANSimpleTable}{Common transfer properties}{|l X|}\label{table:common_transfer_properties}
    Property        & Description \\
    Payload         & The serialized data structure. \\
    Data type ID    & A numerical identifier that indicates how the data structure should be interpreted. \\
    Data type major version number & Semantic major version number of the data type definition. \\
    Source node ID  & The node ID of the transmitting node (excepting anonymous message transfers). \\
    Priority        & A non-negative integer value that defines the transfer urgency (0 is the highest priority).
                      Higher priority transfers can preempt lower priority transfers. \\
    Transfer ID     & A small overflowing integer that increments with every transfer
                      of this data type from a given node. \\
\end{UAVCANSimpleTable}

\subsection{Message broadcasting}

Message broadcasting is the main method of communication between UAVCAN nodes.

A broadcast message is carried by a single message transfer that contains the serialized message data structure.
A broadcast message does not contain any additional fields besides those listed in the table
\ref{table:common_transfer_properties}.

In order to broadcast a message, the broadcasting node must have a node ID that is unique within the network.
An exception applies to \emph{anonymous message broadcasts}.

\subsubsection{Anonymous message broadcasting}

An anonymous message transfer is a transfer that can be sent from a node that does not have a node ID.
This sort of message transfer is especially useful for \emph{dynamic node ID allocation}
(a high-level concept that is reviewed in detail in the chapter \ref{sec:application_layer}).

A node that does not have a node ID is said to be in \emph{passive mode}.
Passive nodes are unable to initiate regular data exchanges,
but they can listen to the data exchanged over the bus,
and they can emit anonymous message transfers.

An anonymous message has the same properties as a regular message, except for the source node ID,
which in the case of anonymous message transfers is always assumed to be zero.

An anonymous transfer can only be a single-frame transfer. Multi-frame anonymous message transfers are not allowed.
This restriction must be kept in mind when designing message data types
intended for use with anonymous message transfers:
when used with anonymous transfers, the whole message must fit into a single CAN frame;
however, the same data type can be used with multi-frame regular (non-anonymous) transfers.

Note that anonymous messages require specific arbitration rules and have restrictions on the acceptable
data type ID values. The details are explained later in this chapter.

\subsubsection{Message timing requirements}

Generally, a message transmission should be aborted if it cannot be completed in 1 second.
Applications are allowed to deviate from this recommendation,
provided that every such deviation is explicitly documented.
It is expected that high-frequency high-priority messages may opt for lower timeout values,
whereas low-priority data may opt for higher timeout values to account for CAN bus congestion.

\subsection{Service invocation}

A service invocation sequence consists of two related service transfers:

\begin{description}
    \item[Service request transfer] - from the node that invokes the service - the \emph{client} - to the node that
    provides the service - the \emph{server}.

    \item[Service response transfer] - once the \emph{server node} receives the service request and processes it,
    it sends a response transfer back to the \emph{client node}.
\end{description}

The tables \ref{table:service_request_transfer_properties} and \ref{table:service_response_transfer_properties}
describe the properties of service request and service response transfers, respectively.

Both the client and the server must have node ID values that are unique within the network;
service invocation is not available to passive nodes.

\begin{UAVCANSimpleTable}{Service request transfer properties}{|l X|}\label{table:service_request_transfer_properties}
    Property                        & Description \\
    Payload                         & The serialized service request data structure. \\
    Data type ID                    & See the table \ref{table:common_transfer_properties}. \\
    Data type major version number  & See the table \ref{table:common_transfer_properties}. \\
    Source node ID                  & The node ID of the client (the invoking node). \\
    Destination node ID             & The node ID of the server (the invoked node). \\
    Priority                        & See the table \ref{table:common_transfer_properties}. \\
    Transfer ID                     & An integer value that:
        \begin{enumerate}
            \item allows the server to distinguish the request from other requests from the same client;
            \item allows the client to match the response with its request.
        \end{enumerate} \\
\end{UAVCANSimpleTable}

\begin{UAVCANSimpleTable}{Service response transfer properties}{|l X|}\label{table:service_response_transfer_properties}
    Property                        & Description \\
    Payload                         & The serialized service response data structure. \\
    Data type ID                    & Same value as in the request transfer. \\
    Data type major version number  & Same value as in the request transfer. \\
    Source node ID                  & The node ID of the server (the invoked node). \\
    Destination node ID             & The node ID of the client (the invoking node). \\
    Priority                        & Same value as in the request transfer. \\
    Transfer ID                     & Same value as in the request transfer. \\
\end{UAVCANSimpleTable}

\subsubsection{Service timing requirements}

Applications should follow the service invocation timing recommendations specified below.
Applications are allowed to deviate from these recommendations,
provided that every such deviation is explicitly documented.

\begin{itemize}
    \item Service transfer transmission should be aborted if does not complete in 1 second.
    \item The client should stop waiting for a response from the server if one has not arrived within 1 second.
\end{itemize}

If the server uses a significant part of the timeout period to process the request,
the client might drop the request before receiving the response.
It is recommended to ensure that the server will be able to process any request in less than 0.5 seconds.

\subsection{Transfer prioritization}\label{sec:transfer_prioritization}

UAVCAN transfers are prioritized by means of the transfer priority property,
which allows eight different priority levels for all types of transfers.
The priority levels and the corresponding numerical identifiers are specified
in the table \ref{table:transfer_priority_levels}.
Observe that due to the specifics of the CAN bus,
lower numerical values correspond to higher priority levels.
The human-friendly mnemonics are introduced in order to prevent confusion due to the inverted nature of the
priority level identifiers.

\begin{minipage}{0.6\textwidth}
\begin{UAVCANSimpleTable}{Transfer priority levels}{|l X|}\label{table:transfer_priority_levels}
    Numerical ID            & Mnemonic \\
    0 (highest priority)    & Emergency \\
    1                       & Critical \\
    2                       & Urgent \\
    3                       & High \\
    4                       & Normal \\
    5                       & Low \\
    6                       & Diagnostic \\
    7 (lowest priority)     & Background \\
\end{UAVCANSimpleTable}
\end{minipage}

Transfers with higher priority levels (i.e., numerically lower priority ID)
preempt transfers with lower priority levels, delaying their transmission
until there are no more higher priority transfers to exchange.

Shall there be multiple transfers of different types at the same priority level contesting for the bus access,
UAVCAN ensures the following precedence, from higher priority to lower priority:

\begin{enumerate}
    \item Message transfers.
    \item Service response transfers.
    \item Service request transfers.
\end{enumerate}

Message transfers take precedence over service transfers because message broadcasting is the primary method of
communication in UAVCAN networks.
Service responses take precedence over service requests in order to make service invocations more atomic
and reduce the number of pending states in the system.

Within the same type and the same priority level,
transfers are prioritized according to the data type ID:
transfers with lower data type ID values preempt those with higher data type ID values.

\section{Transfer emission}

\subsection{Transfer ID computation}\label{sec:transfer_id}\label{sec:transfer_descriptor}

The \emph{transfer ID} is a small unsigned integer value that is provided for every outgoing
transfer.
This value is crucial for many aspects of UAVCAN communication; specifically:
\begin{description}
    \item[Message sequence monitoring] - the continuously increasing transfer ID allows receiving nodes to
    detect lost messages and detect when a message stream from any remote node is interrupted.

    \item[Service response matching] - when a server responds to a request, it uses the same transfer ID for the
    response as in the request,
    allowing any node to emit concurrent requests to the same server while being able to
    match each response with the corresponding request.

    \item[CAN frame deduplication] - for single-frame transfers,
    the transfer ID allows receiving nodes to work around the CAN bus
    frame duplication problem\footnote{This is a well-known issue that can be observed even on a properly
    fielded CAN bus caused by the fact that a frame that appears valid to the receiver may under certain
    (rare) conditions appear invalid to the transmitter, triggering the latter to retransmit the frame,
    in which case it will be duplicated on the side of the receiver.
    Sequence counting mechanisms such as the transfer ID or the toggle bit (both of which are used in UAVCAN)
    allow applications to circumvent this problem.} (multi-frame transfers combat the frame duplication
    problem using the toggle bit).

    \item[Multi-frame transfer reassembly] - more info is provided in the section \ref{sec:transfer_reception}.

    \item[Automatic management of redundant interfaces] - the transfer ID parameter allows the UAVCAN protocol
    stack to perform automatic switchover to a back-up interface shall the primary interface fail.
    The switchover logic can be completely transparent to the application, joining several independent
    redundant physical CAN transports into a highly reliable single virtual communication channel.
\end{description}

For message transfers and service request transfers the ID value should be computed as described below.
For service response transfers this value must be directly copied from the corresponding service request transfer.

The logic to compute the transfer ID relies on the concept of \emph{transfer descriptor}.
A transfer descriptor is a set of properties that identify a particular set of transfers that originate
from the same node, share the same data type ID, same data type major version number, and the same type.
The properties that constitute a transfer descriptor are listed below:
\begin{itemize}
    \item Transfer type (message broadcast, service request, etc.).
    \item Data type ID.
    \item Data type major version number.
    \item Source node ID.
    \item Destination node ID (only for unicast\footnote{I.e., service requests and service responses.} transfers).
\end{itemize}

Every non-passive node must maintain a mapping from transfer descriptors to transfer ID counters.
This mapping is referred to as the \emph{transfer ID map}.

Whenever a node needs to emit a transfer, it will query its transfer ID map for the appropriate transfer descriptor.
If the map does not contain such entry, a new entry will be created with the transfer ID counter initialized to zero.
The node will use the current value of the transfer ID from the map for the transfer,
and then the value stored in the map will be incremented by one.
When the stored transfer ID exceeds its maximum value, it will roll over to zero.

It is expected that some nodes will need to publish certain transfers aperiodically or on an ad-hoc basis,
thereby creating unused entries in the transfer ID map.
In order to avoid keeping unused entries in the map, the nodes are allowed, but not required,
to remove entries from the map that were not used for more than 2 seconds.
Therefore, it is possible that a node may publish a transfer with an out-of-order transfer ID value,
if the previous transfer of the same descriptor has been published more than 2 seconds earlier.

\subsection{Single frame transfers}

If the size of the entire transfer payload does not exceed the space available for payload in a single CAN frame,
the whole transfer will be contained in one CAN frame.
Such transfer is called a \emph{single-frame transfer}.

Single frame transfers are more efficient than multi-frame transfers in terms of throughput, latency,
and data overhead.

\subsection{Multi-frame transfers}

\emph{Multi-frame transfers} are used when the size of the transfer payload exceeds the space available
for payload in a single CAN frame.

Two new concepts are introduced in the context of multi-frame transfers, both of which are reviewed below in detail:
\begin{itemize}
    \item Transfer CRC\footnote{CRC stands for "cyclic redundancy check", an error-detecting code
    added to data transmissions to reduce the likelihood of undetected data corruption.}.
    \item Toggle bit.
\end{itemize}

In order to emit a multi-frame transfer, the node must first compute the CRC for the entirety of the transfer payload.
The node appends the CRC value at the end of the transfer payload,
and then emits the resulting byte set in chunks as an ordered sequence of CAN frames
(i.e. the last CAN frame contains the last bytes of the payload and the transfer CRC).
The data field of all CAN frames of a multi-frame transfer, except the last one, must be fully utilized.

All frames of a multi-frame transfer should be pushed to the transmission queue at once,
in the proper order from the first frame to the last frame.
Explicit gap time between CAN frames belonging to the same transfer should not be introduced.

\subsubsection{Transfer CRC}\label{sec:transfer_crc}

The objective of the transfer CRC is to allow receiving nodes to validate correctness of
multi-frame transfer reassembly.
It should be understood that the transfer CRC is not intended for bit-level data integrity checks,
as that is managed by the CAN bus transport automatically.
As such, the transfer CRC allows receiving nodes to ensure that all of the frames of a multi-frame
transfer were received, all of the received frames were reassembled in the correct order,
and that all of the received frames belong to the same multi-frame transfer.

The transfer CRC is computed over the entire payload of the transfer.
Certain transports, such as CAN FD, may require a short sequence of padding bytes to be added
at the end of the transfer payload due to low granularity of the frame payload length property;
in that case, the padding bytes are not to be included in the CRC computation.

The resulting CRC value is appended to the transfer in the \emph{big-endian byte order}
(most significant byte first),
in order to take advantage of the CRC residue check intrinsic to this algorithm.

The transfer CRC algorithm specification is provided in the table \ref{table:transfer_crc_params}.

\begin{minipage}{0.7\textwidth}
\begin{UAVCANSimpleTable}{Transfer CRC algorithm parameters}{|ll|}\label{table:transfer_crc_params}
    Property        & Value \\
    Name            & CRC-16/CCITT-FALSE \\
    Initial value   & \texttt{0xFFFF} \\
    Polynomial      & \texttt{0x1021} \\
    Reverse         & No \\
    Output XOR      & $0$ \\
    Residue         & $0$ \\
    Check           & $\left(49, 50, \ldots, 56, 57\right) \rightarrow \mathtt{0x29B1}$ \\
\end{UAVCANSimpleTable}
\end{minipage}

The following code snippet provides an implementation of the transfer CRC algorithm in C++.

\begin{minipage}{0.9\textwidth}
\begin{minted}{cpp}
// UAVCAN transfer CRC algorithm implementation in C++.
// License: CC0, no copyright reserved.

#include <iostream>
#include <cstdint>
#include <cstddef>

class TransferCRC
{
    std::uint16_t value_ = 0xFFFFU;

public:
    void add(std::uint8_t byte)
    {
        value_ ^= static_cast<std::uint16_t>(byte) << 8U;
        for (std::uint8_t bit = 8; bit > 0; --bit)
        {
            if ((value_ & 0x8000U) != 0)
            {
                value_ = (value_ << 1U) ^ 0x1021U;
            }
            else
            {
                value_ = value_ << 1U;
            }
        }
    }

    void add(const std::uint8_t* bytes, std::size_t length)
    {
        while (length-- > 0)
        {
            add(*bytes++);
        }
    }

    [[nodiscard]] std::uint16_t get() const { return value_; }
};

int main()
{
    TransferCRC crc;
    crc.add(reinterpret_cast<const std::uint8_t*>("123456789"), 9);
    std::cout << std::hex << "0x" << crc.get() << std::endl;  // Outputs 0x29B1
    return 0;
}
\end{minted}
\end{minipage}

\subsubsection{Toggle bit}\label{sec:toggle_bit}

The toggle bit is a property defined at the CAN frame level.
Its purpose is to detect and avoid CAN frame duplication errors in multi-frame
transfers\footnote{In single-frame transfers, CAN frame deduplication is based on the transfer ID counter.}.

The toggle bit of the first CAN frame of a multi-frame transfer must be set to one.
The toggle bits of the following CAN frames of the transfer must alternate,
i.e., the toggle bit of the second CAN frame must be zero,
the toggle bit of the third CAN frame must be one, and so on.

For single-frame transfers, the toggle bit must be set to one.

Transfers where the initial value of the toggle bit is zero must be ignored.
The initial state of the toggle bit may be inverted in the future revisions of the protocol
to facilitate automatic protocol version detection.

\subsection{Redundant interface support}

In configurations with redundant CAN bus interfaces,
nodes are required to submit every outgoing transfer to the transmission queues of
all available redundant interfaces simultaneously.
It is understood that perfectly simultaneous transmission may not be possible due to different
utilization rates of the redundant interfaces and different phasing of their traffic;
however, that is not an issue for UAVCAN.
If perfectly simultaneous frame submission is not possible, interfaces with lower numerical index
should be handled in the first order.

An exception to the above rule applies if the payload of the transfer depends on some properties
of the interface through which the transfer is emitted.
An example of such a special case is the time synchronization algorithm leveraged by UAVCAN
(documented in the chapter \ref{sec:application_layer} of the specification).

\section{CAN frame format}

UAVCAN utilizes only extended CAN frames with 29-bit identifiers.
UAVCAN can share the same bus with other protocols based on standard (non-extended) CAN frames with 11-bit identifiers.
However, future revisions of UAVCAN may utilize 11-bit identifiers as well;
therefore, backward compatibility with other protocols is not guaranteed.

\subsection{CAN ID structure}

UAVCAN utilizes three different CAN ID formats for different types of transfers:
message transfers, service transfers, and anonymous message transfers.
The structure is summarized in the table \ref{table:can_id_structure}.

{
\setlength\arrayrulewidth{1pt}  % https://tex.stackexchange.com/a/256732/132781
% Please do not remove the hard placement specifier [H], it is needed to keep tables ordered.
\begin{table}[H]\caption{CAN ID structure}\label{table:can_id_structure}
\NoLeftSkip
\begin{tabu}{|c|X[c]|X[c]|X[c]|c|}
    \hline
    \rowfont{\bfseries}
    Bit & Service & Message & Anonymous message & Bit \\\hline

    28 & \multicolumn{3}{c|}{\multirow{3}{*}{Transfer priority}} & 28 \\
    27 & \multicolumn{3}{c|}{} & 27 \\
    26 & \multicolumn{3}{c|}{} & 26 \\
    \hline

    25 & \multicolumn{2}{c|}{Service not message} & \multirow{4}{*}{Reserved, required =0} & 25 \\\cline{2-3}
    24 & Request not response & \multirow{16}{*}{Message data type ID} & & 24 \\\cline{2-2}
    23 & \multirow{8}{*}{Service data type ID} & & & 23 \\
    22 & & & & 22 \\\cline{4-4}
    21 & & & \multirow{3}{*}{Message DTID modulo 8} & 21 \\
    20 & & & & 20 \\
    19 & & & & 19 \\\cline{4-4}
    18 & & & \multirow{10}{*}{Payload discriminator} & 18 \\
    17 & & & & 17 \\
    16 & & & & 16 \\\cline{2-2}
    15 & \multirow{7}{*}{Destination node ID} & & & 15 \\
    14 & & & & 14 \\
    13 & & & & 13 \\
    12 & & & & 12 \\
    11 & & & & 11 \\
    10 & & & & 10 \\
    9 & & & & 9 \\
    \hline

    8 & \multicolumn{3}{c|}{\multirow{7}{*}{Source node ID}} & 8 \\
    7 & \multicolumn{3}{c|}{} & 7 \\
    6 & \multicolumn{3}{c|}{} & 6 \\
    5 & \multicolumn{3}{c|}{} & 5 \\
    4 & \multicolumn{3}{c|}{} & 4 \\
    3 & \multicolumn{3}{c|}{} & 3 \\
    2 & \multicolumn{3}{c|}{} & 2 \\
    \hline

    1 & \multicolumn{3}{c|}{\multirow{2}{*}{Data type major version number modulo 4}} & 1 \\
    0 & \multicolumn{3}{c|}{} & 0 \\
    \hline
    \rowfont{\bfseries}
    Bit & Service & Message & Anonymous message & Bit \\\hline
\end{tabu}
\end{table}
}

The fields are described in detail in the following sections.
The tables \ref{table:can_id_fields_message_transfer},
\ref{table:can_id_fields_anonymous_message_transfer}, and \ref{table:can_id_fields_service_transfer}
summarize the purpose of the fields and their permitted values
for message transfers, anonymous message transfers, and service transfers, respectively.
The following acronyms are used for brevity:
\begin{description}
    \item[DTID] - data type ID.
    \item[DTMVN] - data type major version number.
\end{description}

\begin{UAVCANSimpleTable}{CAN ID fields for message transfers}{|l l l X|}
    \label{table:can_id_fields_message_transfer}
    Field               & Width & Permitted values  & Description \\
    Transfer priority   & 3     & [0, 7] (any)      & \\
    Service not message & 1     & 0                 & Always zero for message transfers. \\
    Message DTID        & 16    & [0, 65535] (any)  & Data type ID of the encoded message data structure. \\
    Source node ID      & 7     & [1, 127]          & Node ID of the origin. \\
    Message DTMVN       & 2     & [0, 3] (any)      & Major version number of the data type, modulo 4. \\
\end{UAVCANSimpleTable}

\begin{UAVCANSimpleTable}{CAN ID fields for anonymous message transfers}{|l l l X|}
    \label{table:can_id_fields_anonymous_message_transfer}
    Field               & Width & Permitted values  & Description \\
    Transfer priority   & 3     & [0, 7] (any)      & \\
    Reserved field      & 4     & 0                 & Set to zero when emitting. When receiving, ignore the
                                                      frame if this field is not zero. \\
    Message DTID modulo 8& 3    & [0, 7] (any)      & Three least significant bits of the data type ID of the
                                                      encoded message data structure. Message types where DTID is
                                                      greater than 7 cannot be used with anonymous message transfers. \\
    Payload discriminator & 10  & [0, 1023] (any)   & Used for CAN ID conflict avoidance;
                                                      see section \ref{sec:can_payload_discriminator}. \\
    Source node ID      & 7     & 0                 & Set to zero. This field is used to distinguish anonymous message
                                                      transfers from regular message transfers. \\
    Message DTMVN       & 2     & [0, 3] (any)      & Major version number of the data type, modulo 4. \\
\end{UAVCANSimpleTable}

\begin{UAVCANSimpleTable}{CAN ID fields for service transfers}{|l l l X|}
    \label{table:can_id_fields_service_transfer}
    Field               & Width & Permitted values  & Description \\
    Transfer priority   & 3     & [0, 7] (any)      & \\
    Service not message & 1     & 1                 & Always one for service transfers. \\
    Request not response& 1     & \{0, 1\} (any)    & 1 for service request, 0 for service response. \\
    Service DTID        & 8     & [0, 255] (any)    & Data type ID of the encoded service data structure
                                                      (request or response). \\
    Destination node ID & 7     & [1, 127]          & Node ID of the destination
                                                      (i.e., server for requests, client for responses). \\
    Source node ID      & 7     & [1, 127]          & Node ID of the origin
                                                      (i.e., client for requests, server for responses). \\
    Service DTMVN       & 2     & [0, 3] (any)      & Major version number of the data type, modulo 4. \\
\end{UAVCANSimpleTable}

\subsubsection{Transfer priority}

Valid values for priority range from 0 to 7, inclusively,
where 0 corresponds to the highest priority, and 7 corresponds to the lowest priority.
Mnemonics for transfer priority levels are provided in the table \ref{table:transfer_priority_levels}.

In multi-frame transfers, the value of the priority field must be identical for all frames of the transfer.

\subsubsection{Data type ID}

A higher-level review of the concept of data type ID is available in the chapter \ref{sec:dsdl}.

Valid values of message type ID belong to the range [0, 65535].
For anonymous message transfers, however, the range of usable message type ID values
is limited to [0, 7];
messages with data type ID outside of this range cannot be used with anonymous message
transfers\footnote{This is considered to be an acceptable limitation because anonymous transfers
are intended for an extremely limited set of use cases.}.

Valid values of service type ID belong to the range [0, 255].

More information on the data type ID value ranges is available in the chapter \ref{sec:application_layer}.

\subsubsection{Data type major version number}

As explained in the section \ref{sec:dsdl_versioning},
the difference between the lowest and the highest released major version numbers of any given data type
may never exceed three.

Having made certain assumptions about the data type release cadence and the deprecation strategy,
one can see that the transport layer can represent the data type major version number using a reduced
modulo 4 representation; i.e., instead of carrying the whole version number, the transport layer
can carry only the major version number modulo four:
$$V^\prime{} = V \bmod 4 \Leftrightarrow{} V \geq{} 0$$
where $V$ is the data type major version number and $V^\prime{}$ is its reduced representation used by
the transport layer.

Taking advantage of the fact that the transport layer representation of the major data type version number
belongs to [0, 3], UAVCAN uses only a two-bit wide field in the CAN identifier to represent the major
version number.

The bit width saving measures described here warrant certain special handling rules for the major version
number at the transport layer.
When emitting a transfer, the node must compute the modulo of the major data type version number
as described above, and populate the corresponding CAN ID field with the resulting value.
When receiving a transfer, the node must search for an appropriate data type definition
among the known definitions by looking for the one which has the same major version number modulus
as the received modulus:
$$V_\text{local} \bmod 4 = V^\prime{}$$
where $V_\text{local}$ is the major version number of the locally available data type definition that will be used
to process the transfer.

From the above description one can see that a data type mismatch will occur if the absolute difference between
the major data type version used by the emitter and that used by the receiver exceeds three:
$$V_\text{local} \neq V \Leftrightarrow{} \vert{}V_\text{local} - V\vert{} \geq 4$$
However, due to the implicit deprecation policy defined in the section \ref{sec:dsdl_versioning},
the risk of version conflict is easy to avoid, and the limitation is therefore deemed acceptable.

\subsubsection{Node ID}

Valid values of node ID belong to the range [1, 127].

Node ID is represented by a 7-bit unsigned integer value; zero is reserved.
A node ID of zero is used to represent either an unknown node or all nodes, depending on the context.

As such, for anonymous message transfers, the source node ID field is always set to zero.
By observing a source node ID of zero, receiving nodes can distinguish
anonymous message transfers from other types of transfers.

\subsubsection{Payload discriminator}\label{sec:can_payload_discriminator}

CAN bus does not allow different nodes to transmit CAN frames with different data field values under the same CAN ID.
Owing to the fact that the CAN ID includes the node ID value of the transmitting node,
this restriction does not affect regular UAVCAN transfers.
However, anonymous message transfers would violate this restriction,
because they all share the same node ID of zero.

In order to work-around this problem,
UAVCAN adds a \emph{payload discriminator} to the CAN ID of anonymous message transfers,
and defines special logic for handling CAN bus errors during transmission of anonymous frames.

The payload discriminator field must be filled with pseudorandom data whenever a node transmits an
anonymous message transfer.
The source of the pseudorandom data must be likely to produce different discriminator values
for different data field values.
A possible way of initializing the payload discriminator value is to apply the transfer CRC function
(as defined in the section \ref{sec:transfer_crc})
to the contents of the anonymous message, and then use any 10 bits of the result.
Nodes that adopt this approach will be using the same payload discriminator value for identical messages,
which is acceptable since this will not trigger an error on the bus.

Since the discriminator is only 10 bits long,
the probability of having multiple nodes emitting CAN frames with the same CAN ID
but different data can exceed 0.1\%, which is significant.
Therefore, the protocol must account for possible errors on the CAN bus triggered by CAN ID collisions.
In order to comply with this requirement,
UAVCAN requires all nodes to immediately abort transmission of all anonymous transfers once an error on
the CAN bus is detected.
This measure allows the protocol to prevent the bus deadlock that may occur if the automatic
retransmission on bus error is not suppressed.

\subsection{CAN frame data}

The CAN frame data field may contain the following data items, in the listed order:
\begin{enumerate}
    \item The useful payload (serialized data structure). This segment may be empty.
    \item Possible padding bytes.
          Padding bytes may be necessary if the transport layer does not provide byte-level
          granularity of the data field length (e.g., CAN FD).
    \item The last frame of multi-frame transfers always contains the transfer CRC (section \ref{sec:transfer_crc}).
    \item The last byte of the data field always contains the \emph{tail byte}.
\end{enumerate}
The segments are documented below in this section.

\subsubsection{Tail byte}

UAVCAN adds one byte of overhead to every CAN frame irrespective of the type of the transfer.
The extra byte contains certain metadata for the needs of the transport layer.
It is named the \emph{tail byte}, and as the name suggests, it is always situated
at the very last byte of the data field of every CAN frame.
The tail byte contains four fields: \emph{start of transfer}, \emph{end of transfer},
\emph{toggle bit}, and the transfer ID (described earlier in the section \ref{sec:transfer_id}).
The placement of the fields and their usage for single-frame and multi-frame transfers
are documented in the table \ref{table:tail_byte}.

% Please do not remove the hard placement specifier [H], it is needed to keep tables ordered.
\begin{table}[H]\caption{Tail byte structure}\label{table:tail_byte}
\begin{tabu}{|c|l|X[2]|X[3]|}
    \hline
    \rowfont{\bfseries}
    Bit & Field & Single-frame transfers & Multi-frame transfers \\
    \hline

    7   & Start of transfer & Always 1  & First frame: 1, otherwise 0. \\\hline
    6   & End of transfer   & Always 1  & Last frame: 1, otherwise 0. \\\hline
    5   & Toggle bit        & Always 1  & First frame: 1, then alternates; section \ref{sec:toggle_bit}. \\\hline

    4   &               & \multicolumn{2}{c|}{} \\
    3   &               & \multicolumn{2}{c|}{Modulo 32 (range [0, 31])} \\
    2   & Transfer ID   & \multicolumn{2}{c|}{section \ref{sec:transfer_id}} \\
    1   &               & \multicolumn{2}{c|}{} \\
    0   &               & \multicolumn{2}{c|}{\footnotesize{(least significant bit)}} \\
    \hline
\end{tabu}
\end{table}

The transfer ID field is populated according to the specification provided in the section \ref{sec:transfer_id}.
The usage of this field is independent of the type of the transfer.

For single-frame transfers, the fields start-of-transfer, end-of-transfer, and the toggle bit
are all set to~1.

For multi-frame transfers, the fields start-of-transfer and end-of-transfer
are used to state the boundaries of the current transfer as described in the table.
The transfer ID value is identical for all frames of a multi-frame transfer.

The toggle bit, as described in the section \ref{sec:toggle_bit}, serves
two main purposes: CAN frame deduplication and protocol version detection.

\subsubsection{Padding bytes}

Certain transports (such as CAN FD) may not provide byte-level granularity of the CAN data field length.
In that case, the useful payload is to be padded with the minimal number of padding bytes required
to bring the total length of the CAN data field to a value that can satisfy the length granularity constraints.

When transmitting, each padding byte must be set to $\text{85} = \text{55}_\text{hex} = \text{0101\,0101}_\text{bin}$.
This specific padding value is chosen to avoid stuff bits on transports that leverage a non-return-to-zero
type of modulation, and to facilitate transceiver synchronization on communication mediums that use implicit clocking.

When receiving, the values of the padding bytes must be ignored.
In other words, receiving nodes must not make any assumptions about the values of the
padding bytes.

Usage of padding bytes implies that when a serialized message is being deserialized by a receiving node,
the byte sequence used for deserialization may be longer than the actual byte sequence generated by the
emitting node during serialization.
Therefore, nodes must ignore the trailing unused data bytes at the end of serialized byte sequences;
a length mismatch is only to be considered an error if the received byte sequence is shorter
than expected by the deserialization routine.

\subsubsection{Single-frame transfers}

For single-frame transfers, the data field of the CAN frame contains two or three segments:
the useful payload (which is the serialized data structure, may be empty), possible padding bytes,
and the tail byte (the last byte of the data field).

The resulting data field segmentation is shown in the table \ref{table:can_data_segments_single_frame}.

\begin{table}[H]\caption{CAN frame data segments for single-frame transfers}
\label{table:can_data_segments_single_frame}
\begin{tabu}{|l l X|}
    \hline
    \rowfont{\bfseries}
    Offset                  & Length                     & Segment \\\hline
    $0$                     & $L_\text{payload}\geq{}0$  & Useful payload (serialized data structure). \\\hline
    $L_\text{payload}$      & $L_\text{padding}\geq{}0$  & Padding bytes (if necessary). \\\hline
    $L_\text{payload} + L_\text{padding}$ & $1$          & Tail byte. \\\hline
\end{tabu}
\end{table}

\subsubsection{Multi-frame transfers}

For multi-frame transfers, all frames except the last one contain only a fragment
of the useful payload and the tail byte.
Notice that the padding bytes are not used in multi-frame transfers, excepting the last frame.

The useful payload is fragmented in the forward order: the first CAN frame of a multi-frame transfer
contains the beginning of the payload (the first fragment),
the following frames contain the subsequent fragments of the useful payload.
The last CAN frame of a multi-frame transfer contains the last fragment, unless
the last fragment was fully accommodated by the previous CAN frame of the transfer.
In the latter case, the last CAN frame will contain only the metadata,
as specified below in this section.

Each CAN frame of a multi-frame transfer except the last one
should use the maximum CAN data length permitted by the transport.
Observe that this is not a hard requirement;
some systems that utilize CAN FD may opt for shorter CAN frames in order to reduce the worst case
preemption latency.
Therefore, UAVCAN implementations must be able to correctly process multi-frame transfers with arbitrary
CAN frame data lengths.

The resulting data field segmentation for all frames of a multi-frame transfer except the last one is
shown in the table \ref{table:can_data_segments_multi_frame_not_last}.

\begin{table}[H]\caption{CAN frame data segments for multi-frame transfers (except the last CAN frame of the transfer)}
\label{table:can_data_segments_multi_frame_not_last}
\begin{tabu}{|l l X|}
    \hline
    \rowfont{\bfseries}
    Offset                  & Length                & Segment \\\hline
    $0$                     & $L_\text{payload}>0$  & A fragment of the useful payload (serialized data structure).
                                                      This segment occupies the entirety of the CAN data field
                                                      except the last byte, which is used by the tail byte. \\\hline
    $L_\text{payload}$      & $1$                   & Tail byte. \\\hline
\end{tabu}
\end{table}

The last CAN frame of a multi-frame transfer contains one or two additional segments:
the padding bytes (if necessary) and the transfer CRC.
The padding rules are identical to those of single-frame transfers.
The transfer CRC is to be allocated in the big-endian byte order\footnote{Most significant byte first.
This byte order is used to allow faster CRC residue checks; more info in section \ref{sec:transfer_crc}.}
immediately before the tail byte.
The resulting data field segmentation is shown in the table \ref{table:can_data_segments_multi_frame_last}.

\begin{table}[H]\caption{CAN frame data segments for multi-frame transfers (the last CAN frame of the transfer)}
\label{table:can_data_segments_multi_frame_last}
\begin{tabu}{|l l X|}
    \hline
    \rowfont{\bfseries}
    Offset                  & Length                     & Segment \\\hline
    $0$                     & $L_\text{payload}\geq{}0$  & The last fragment of the useful payload
                                                           (serialized data structure). \\\hline
    $L_\text{payload}$      & $L_\text{padding}\geq{}0$  & Padding bytes (if necessary). \\\hline

    \multirow{2}{*}{$L_\text{payload} + L_\text{padding}$} & \multirow{2}{*}{$2$} &
                                                           Transfer CRC, high byte.\\
                            &                            & Transfer CRC, low byte.\\\hline

    $L_\text{payload} + L_\text{padding} + 2$ & $1$        & Tail byte. \\\hline
\end{tabu}
\end{table}

\section{Transfer reception}\label{sec:transfer_reception}

\subsection{Transfer ID comparison}

The following explanation relies on the concept of the \emph{transfer ID forward distance}.
Transfer ID forward distance $F$ is a function of two transfer ID values,
$A$ and $B$, that defines the number of increment operations that need to be applied to
$A$ so that $A^\prime{} = B$, assuming modulo 32 arithmetic:
$$A + F = B \quad (\bmod{}\ 32)$$
Consider the examples provided in the table \ref{table:transfer_id_fwd_dst_ex}.

The \emph{half range} of transfer ID is 16.

\begin{minipage}{0.6\textwidth}
\begin{UAVCANSimpleTable}{Transfer ID forward distance examples}{|X[c] X[c]|X[c]|}
    $A$ & $B$   & $F$ \label{table:transfer_id_fwd_dst_ex} \\
    0   & 0     & 0 \\
    0   & 5     & 5 \\
    5   & 0     & 27 \\
    31  & 30    & 31 \\
    31  & 0     & 1 \\
\end{UAVCANSimpleTable}
\end{minipage}

The following code sample provides an example implementation of the transfer ID comparison algorithm in C++.

\begin{minipage}{0.9\textwidth}  % Mini page is needed to prevent page breaks within the snippet
\begin{minted}{cpp}
// UAVCAN transfer ID forward distance computation algorithm implemented in C++.
// License: CC0, no copyright reserved.

#include <cstdint>
#include <iostream>
#include <cassert>

constexpr std::uint8_t TransferIDBitLength = 5;

[[nodiscard]]
constexpr std::int8_t computeForwardDistance(std::uint8_t a, std::uint8_t b)
{
    constexpr std::uint8_t MaxValue = (1U << TransferIDBitLength) - 1U;
    assert((a <= MaxValue) && (b <= MaxValue));

    std::int16_t d = static_cast<std::int16_t>(b) - static_cast<std::int16_t>(a);
    if (d < 0)
    {
        d += 1U << TransferIDBitLength;
    }

    assert((d <= MaxValue) && (d >= -MaxValue));
    assert(((a + d) & MaxValue) == b);
    return static_cast<std::int8_t>(d);
}

int main()
{
    assert(0  == computeForwardDistance(0, 0));
    assert(1  == computeForwardDistance(0, 1));
    assert(7  == computeForwardDistance(0, 7));
    assert(0  == computeForwardDistance(7, 7));
    assert(31 == computeForwardDistance(31, 30)); // overflow
    assert(1  == computeForwardDistance(31, 0));  // overflow
    return 0;
}
\end{minted}
\end{minipage}

\subsection{State variables}

Nodes that receive transfers must keep a certain set of state variables for each
transfer descriptor\footnote{The concept of \emph{transfer descriptor} is explained
in the section \ref{sec:transfer_descriptor}.}.
The set of state variables will be referred to as the \emph{receiver state}.
For the purposes of this specification, it is assumed that the node will maintain a
mapping from transfer descriptors to receiver states, which will be referred to as the \emph{receiver map}.
It is understood, however, that real implementations may resort to different architectures as
long as the resulting behavior of the node observable at the protocol level is functionally equivalent.

The list of receiver state variables is provided in the table \ref{table:transfer_receiver_state_variables}.
Operations defined on receiver states are listed in the table
\ref{table:transfer_receiver_state_operations};
and the set of conditions defined for receiver states is provided in the table
\ref{table:transfer_receiver_state_conditions}.

Whenever a node receives a transfer, it will query its receiver map for the matching transfer descriptor.
If the matching state does not exist, the node will add a new uninitialized receiver state to the map.
The node then will proceed with the procedure of \emph{receiver state update}, which is defined below in this section.

It is expected that some transfers will be aperiodic or ad-hoc,
which implies that the receiver map may over time accumulate receiver states that are no longer used.
Therefore, nodes are allowed, but not required, to remove any receiver state from the receiver map,
once the state reaches the \emph{transfer ID timeout condition}.

Receiver state can only be modified when a new CAN frame of a matching transfer is received.
This guarantee simplifies implementation, as it implies that the receiver states will not
require any background maintenance processes.

\begin{UAVCANSimpleTable}{Transfer reception state variables}{|l X|}
    State               & Description \label{table:transfer_receiver_state_variables} \\
    Transfer payload    & Useful payload byte sequence; extended upon reception of CAN frames. \\
    Transfer ID         & The transfer ID value of the current transfer or the next expected transfer.
                          Section \ref{sec:transfer_id}. \\
    Next toggle bit     & Expected value of the toggle bit in the next CAN frame.
                          Section \ref{sec:toggle_bit}. \\
    Transfer timestamp  & The local monotonic timestamp sampled when the first frame of the transfer arrived.
                          Here, "monotonic" means that the reference clock does not change its rate or leap. \\
    Interface index     & Only in the case of redundant transport interfaces. \\
\end{UAVCANSimpleTable}

\begin{UAVCANSimpleTable}{Transfer reception state operations}{|l X|}
    Operation   & Description \label{table:transfer_receiver_state_operations} \\

    Extension   & Add newly received useful payload data to the current transfer payload state. \\

    Restart     & Reset the state variables to match the parameters of a new transfer.
                  A reset can only be performed synchronously with the reception of a matching CAN frame
                  which is the first frame of a new transfer (e.g. the start of transfer flag is set).
                  A reset operation includes at least the following:
                  \begin{itemize}
                      \item Clearing (emptying) the transfer payload state.
                      \item Updating the transfer ID state with the actual transfer ID value from the new transfer.
                      \item Setting the toggle bit to its initial state (section \ref{sec:toggle_bit}).
                      \item Initializing the transfer timestamp with the reception timestamp from the CAN frame.
                      \item Initializing the interface index (for nodes with redundant interfaces only).
                  \end{itemize}\\
\end{UAVCANSimpleTable}

\begin{UAVCANSimpleTable}{Transfer reception state conditions}{|l X|}
    Condition       & Description \label{table:transfer_receiver_state_conditions} \\

    Uninitialized   &
    The default condition, which indicates that the receiver state has not yet seen any transfers. \\

    Transfer ID timeout &
    Last matching transfer was seen more than 2 seconds ago.\\

    Interface switch allowed &
    This condition is only applicable for configurations with redundant CAN bus interfaces.
    It means that the node is allowed to receive the next transfer from an interface that is not the same
    the previous transfer was received from.
    The condition is reached when the last matching transfer has been successfully received more than
    $T_\text{switch}$ seconds ago. The value of $T_\text{switch}$ must not exceed 2 seconds.
    The actual value of $T_\text{switch}$ can be either a constant chosen by the designer according
    to the application requirements (e.g., maximum recovery time in the event of an interface failure),
    or the protocol stack can estimate this value automatically by analyzing the transfer intervals. \\
\end{UAVCANSimpleTable}

\subsection{State update in a redundant interface configuration}

The following pseudocode demonstrates the transfer reception process
for a configuration with redundant CAN bus interfaces.

\clearpage
\begin{minted}{cpp}
// Constants:
tid_timeout := 2 seconds;
tid_half_range := 16;
iface_switch_delay := UserDefinedConstant; // Or autodetect

// State variables:
initialized := 0;
payload;
this_transfer_timestamp;
current_transfer_id;
iface_index;
toggle;

function receiveFrame(frame)
{
    // Resolving the state flags:
    tid_timed_out := (frame.timestamp - this_transfer_timestamp) > tid_timeout;
    same_iface := frame.iface_index == iface_index;
    first_frame := frame.start_of_transfer;
    non_wrapped_tid := computeForwardDistance(current_transfer_id, frame.transfer_id) < tid_half_range;
    not_previous_tid := computeForwardDistance(frame.transfer_id, current_transfer_id) > 1;
    iface_switch_allowed := (frame.timestamp - this_transfer_timestamp) > iface_switch_delay;

    // Using the state flags from above, deciding whether we need to reset:
    need_restart :=
        (!initialized) or
        (tid_timed_out) or
        (same_iface and first_frame and not_previous_tid) or
        (iface_switch_allowed and first_frame and non_wrapped_tid);

    if (need_restart)
    {
        initialized := 1;
        iface_index := frame.iface_index;
        current_transfer_id := frame.transfer_id;
        payload.clear();
        toggle := 0;
        if (!first_frame)
        {
            current_transfer_id.increment();
            return;         // Ignore this frame, since the start of the transfer has already been missed
        }
    }

    if (frame.iface_index != iface_index)
    {
        return;  // Wrong interface, ignore
    }

    if (frame.toggle != toggle)
    {
        return;  // Unexpected toggle bit, ignore
    }

    if (frame.transfer_id != current_transfer_id)
    {
        return;  // Unexpected transfer ID, ignore
    }

    if (first_frame)
    {
        this_transfer_timestamp := frame.timestamp;
    }

    toggle := !toggle;
    payload.append(frame.data);

    if (frame.last_frame)
    {
        // CRC validation for multi-frame transfers is intentionally omitted for brevity
        processTransfer(payload, ...);

        current_transfer_id.increment();
        toggle := 0;
        payload.clear();
    }
}
\end{minted}

\subsection{State update in a non-redundant interface configuration}

The following pseudocode demonstrates the transfer reception process for a configuration
with a non-redundant CAN bus interface.
This is a specialization of the more general algorithm defined for redundant transport.

\clearpage
\begin{minted}{cpp}
// Constants:
tid_timeout := 2 seconds;

// State variables:
initialized := 0;
payload;
this_transfer_timestamp;
current_transfer_id;
toggle;

function receiveFrame(frame)
{
    // Resolving the state flags:
    tid_timed_out := (frame.timestamp - this_transfer_timestamp) > tid_timeout;
    first_frame := frame.start_of_transfer;
    not_previous_tid := computeForwardDistance(frame.transfer_id, current_transfer_id) > 1;

    // Using the state flags from above, deciding whether we need to reset:
    need_restart :=
        (!initialized) or
        (tid_timed_out) or
        (first_frame and not_previous_tid);

    if (need_restart)
    {
        initialized := 1;
        current_transfer_id := frame.transfer_id;
        payload.clear();
        toggle := 0;
        if (!first_frame)
        {
            current_transfer_id.increment();
            return; // Ignore this frame, since the start of the transfer has already been missed
        }
    }

    if (frame.toggle != toggle)
    {
        return;  // Unexpected toggle bit, ignore
    }

    if (frame.transfer_id != current_transfer_id)
    {
        return;  // Unexpected transfer ID, ignore
    }

    if (first_frame)
    {
        this_transfer_timestamp := frame.timestamp;
    }

    toggle := !toggle;
    payload.append(frame.data);

    if (frame.last_frame)
    {
        // CRC validation for multi-frame transfers is intentionally omitted for brevity
        processTransfer(payload, ...);

        current_transfer_id.increment();
        toggle := 0;
        payload.clear();
    }
}
\end{minted}

\section{CAN bus requirements}

The chapter \ref{sec:hardware_design_recommendations} contains important information
concerning the CAN bus bit rate, connectors, and other properties of the physical layer of the protocol.

\subsection{CAN controller driver software}

Multi-frame transfers use identical CAN ID for all frames of the transfer,
and UAVCAN requires that all frames of a multi-frame transfer should be transmitted in the correct order.
Therefore, the CAN controller driver software must ensure that CAN frames with identical CAN ID values
must be transmitted in their order of appearance in the transmission queue.
Some CAN controllers will not meet this requirement by default,
so the designer must take special care to ensure the correct behavior, and apply workarounds if necessary.
